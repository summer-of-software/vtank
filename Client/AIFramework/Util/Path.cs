using System;
using System.Collections.Generic;
using System.Text;

namespace AIFramework.Util
{
    /// <summary>
    /// Represents a path generated by a pathfinding algorithm.
    /// </summary>
    public class Path
    {
        #region Members
        private LinkedList<Node> nodeList;
        #endregion

        #region Properties
        /// <summary>
        /// Gets whether or not this path is empty (has no nodes).
        /// </summary>
        public bool IsEmpty
        {
            get
            {
                return nodeList.Count == 0;
            }
        }

        /// <summary>
        /// Take a look at the first value in the path.
        /// </summary>
        public Node Peek
        {
            get
            {
                if (Count == 0)
                {
                    return null;
                }

                return nodeList.First.Value;
            }
        }

        /// <summary>
        /// Take a look at the second value in the path.
        /// </summary>
        public Node PeekMore
        {
            get
            {
                if (Count <= 1)
                {
                    return null;
                }

                return nodeList.First.Next.Value;
            }
        }

        /// <summary>
        /// Look at the last value in the path.
        /// </summary>
        public Node Last
        {
            get
            {
                return nodeList.Last.Value;
            }
        }

        /// <summary>
        /// Gets the number of nodes in this path.
        /// </summary>
        public int Count
        {
            get
            {
                return nodeList.Count;
            }
        }
        #endregion

        #region Constructor
        public Path()
        {
            nodeList = new LinkedList<Node>();
        }
        #endregion

        #region Methods
        public override string ToString()
        {
            StringBuilder buffer = new StringBuilder();
            foreach (Node node in nodeList)
            {
                buffer.Append(node.ToString());
                buffer.Append(", ");
            }

            return buffer.ToString();
        }

        /// <summary>
        /// Append a node onto the path.
        /// </summary>
        /// <param name="node">Node to append.</param>
        public void AppendNode(Node node)
        {
            nodeList.AddLast(node);
        }

        /// <summary>
        /// Pop the next-most node in the list off of the list.
        /// </summary>
        /// <returns>Value of the popped node.</returns>
        public Node Pop()
        {
            if (Count == 0)
            {
                return null;
            }

            LinkedListNode<Node> first = nodeList.First;
            nodeList.RemoveFirst();

            return first.Value;
        }

        /// <summary>
        /// Optimize a path. This will remove any nodes in the middle and leave only
        /// significant nodes.
        /// </summary>
        public static Path Optimize(Path path)
        {
            if (path.IsEmpty || path.Peek == path.Last || path.Count == 2)
            {
                // Cannot optimize further.
                return path;
            }

            Path copy = new Path();
            Node prev = null;
            Node next = null;
            int directionX = 10000;
            int directionY = 10000;

            while ((next = path.Pop()) != null)
            {
                if (prev == null) 
                {
                    // First node.
                    prev = next;
                    copy.AppendNode(prev);
                    Node next2 = path.Peek;
                    directionX = next2.X - prev.X;
                    directionY = next2.Y - prev.Y;
                    continue;
                }

                int deltaX = next.X - prev.X;
                int deltaY = next.Y - prev.Y;
                if (deltaX != directionX || deltaY != directionY)
                {
                    // Direction has changed.
                    directionX = deltaX;
                    directionY = deltaY;
                    copy.AppendNode(prev);
                }
                else if (path.Count == 0)
                {
                    // We're at the last node.
                    copy.AppendNode(next);
                }

                prev = next;
            }

            return copy;
        }
        #endregion
    }

    #region class Node
    /// <summary>
    /// A 'node' is a single square in the path.
    /// </summary>
    public class Node : IComparable<Node>
    {
        #region Properties
        /// <summary>
        /// Gets the 'x' position of this node. This represents it's position in
        /// 'tiles', not in pixels.
        /// </summary>
        public int X
        {
            get;
            set;
        }

        /// <summary>
        /// Gets the 'y' position of this node. This represents it's position in
        /// 'tiles', not in pixels.
        /// </summary>
        public int Y
        {
            get;
            set;
        }
        #endregion

        #region Constructor
        /// <summary>
        /// Creates a new walkable node.
        /// </summary>
        /// <param name="x">X position (in tiles).</param>
        /// <param name="y">Y position (in tiles).</param>
        public Node(int x, int y)
        {
            X = x;
            Y = y + 1;
        }
        #endregion

        #region Methods
        /// <summary>
        /// Converts the 'X' coordinate from tiles to pixels for the purposes of
        /// movement.
        /// </summary>
        /// <returns>Pixel value of 'X'.</returns>
        public int ToPixelsX()
        {
            return X * AIFramework.Bot.Game.Tile.TILE_SIZE_IN_PIXELS + 32;
        }

        /// <summary>
        /// Converts the 'Y' coordinate from tiles to pixels for the purposes of
        /// movement.
        /// </summary>
        /// <returns>Pixel value of 'Y'.</returns>
        public int ToPixelsY()
        {
            return -(Y * AIFramework.Bot.Game.Tile.TILE_SIZE_IN_PIXELS - 32);
        }

        /// <summary>
        /// Converts the node to a string-readable format.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return String.Format("[({0}, {1})=>({2}, {3}]", ToPixelsX(), ToPixelsY(), X, Y);
        }
        #endregion

        #region IComparable<Node> Members

        public int CompareTo(Node other)
        {
            if (Y != other.Y)
            {
                return Y.CompareTo(other.Y);
            }

            return X.CompareTo(other.X);
        }

        #endregion
    }
    #endregion
}
